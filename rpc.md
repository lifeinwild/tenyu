# 概要
SOMというRPCによる異種プロセス間連携及びハイパーリンク（URL)の構想を提案する。

ここで異種プロセスはクラス定義を事前に共有できないプロセス。逆に同種プロセス間連携とは例えばP2Pプラットフォームで、どのノードも同じソフトウェアを実行しているので事前にクラス定義を完全に共有できる。

全体として特殊なアイデアはあまりなく、複数の簡単な選択の組み合わせ。
アプリ名によるURLや検証アーキテクチャはちょっとしたアイデアと言える。検証アーキテクチャはRPCに限った事ではなく情報処理システム一般のアイデア。

# 目次
<!-- TOC -->

- [概要](#概要)
- [目次](#目次)
- [筆者](#筆者)
- [一般用語](#一般用語)
    - [プロセス](#プロセス)
    - [ハイパーリンク](#ハイパーリンク)
    - [IPC](#ipc)
    - [RPC](#rpc)
    - [JSON](#json)
    - [JSON-RPC](#json-rpc)
    - [Rison](#rison)
    - [URL](#url)
- [問題](#問題)
    - [URLの問題](#urlの問題)
    - [JSON-RPCの問題](#json-rpcの問題)
    - [RPCのクラス定義の共有と自動作成の問題](#rpcのクラス定義の共有と自動作成の問題)
    - [検証処理の問題](#検証処理の問題)
- [解決](#解決)
    - [Single_Object_Message](#single_object_message)
        - [SOMプロトコル](#somプロトコル)
        - [実装](#実装)
    - [SOMのURLフォーマット](#somのurlフォーマット)
    - [localhost内のプロセスがRPCでアクセスしてきたユーザーを特定する方法](#localhost内のプロセスがrpcでアクセスしてきたユーザーを特定する方法)
    - [機能毎にクラスを用意する](#機能毎にクラスを用意する)
    - [共有されるクラス](#共有されるクラス)
    - [HTTP前提](#http前提)
    - [localhost内の異種システム間連携](#localhost内の異種システム間連携)
    - [検証処理](#検証処理)
        - [モデル検証](#モデル検証)
        - [周辺検証](#周辺検証)
- [余談](#余談)
    - [世のRPC実装の状況](#世のrpc実装の状況)
    - [考察過程メモ](#考察過程メモ)
    - [連鎖RPC](#連鎖rpc)

<!-- /TOC -->

# 筆者
https://twitter.com/lifeinwild  
exceptiontenyu@gmail.com  
satoji@protonmail.com  
lifeinwild1@gmail.com  

# 一般用語
## プロセス
プロセスという言葉は一般的には手順のような意味だが、プログラミングではOSが提供するある種の仮想環境（仮想アドレス空間から）を意味する。

プロセスは１個のアプリだと思っておけば概ね間違いない。（厳密には１アプリで複数プロセスを使用するものもあるし１プロセス上で複数アプリが動作する場合もありうる）

プロセス概念の本質は、カーネルが多数のアプリの同時実行を可能にする上でアプリ間の相互の破壊的干渉を防止する事にある。メモリ等の共用リソースにおいて競合系の問題（同じところに書き込んで他のアプリのデータを上書きするとか）を起こさないようにするためにプロセス概念が必要になる。（共用リソースの競合問題の解決はカーネル概念の本質でもある）

https://ja.wikipedia.org/wiki/%E3%83%97%E3%83%AD%E3%82%BB%E3%82%B9

## ハイパーリンク
良くWEBページで見かけるクリック可能な青い文字列。  
https://www.w3.org/MarkUp/html-spec/html-spec_7.html

ハイパーリンクはハイパーテキスト前提の概念だが、SOMではクリックした時に任意のRPCを呼び出すものと捉えなおしハイパーテキストに限定されないものとみなしている。

## IPC
プロセス間通信。  
http://e-words.jp/w/IPC.html  
https://en.wikipedia.org/wiki/Inter-process_communication  

SOMではlocalhost内でのプロセス間通信とネットワーク越しのプロセス間通信の両方を考える。

## RPC
異なるプロセスのプロシージャ（メソッド等）を呼び出す。  
http://e-words.jp/w/RPC.html  
https://en.wikipedia.org/wiki/Remote_procedure_call  

とはいえ、RPCの仕組みに乗じて自プロセスのプロシージャを呼び出す事も一応考えられる。

## JSON
オブジェクトを文字列化したもの。  
https://www.json.org/json-en.html  

かなり普及していて各言語にオブジェクトをJSON化するライブラリがある。JSONはもともとJavaScriptというプロトタイプ由来のアイデアだが、jackson等クラスベースの言語のライブラリはJSONにクラス名を記入する設定がある。   

## JSON-RPC
”メソッド呼び出し”を１個の文字列としたもの、またはそれによってRPCを実現するプロトコル。呼び出すメソッド名とそのメソッドへの引数が文字列で記述される。引数はJSONで記述される。  
https://www.jsonrpc.org/specification

## Rison
[JSON](#JSON)をURL引数に埋め込みやすくしたもの。URLエンコードの影響（％の多発）を受けにくい  
https://qiita.com/townewgokgok/items/290c587c30b583dacd9e  
https://rison.io/  
https://github.com/bazaarvoice/rison  

欠点として、一部のアプリはRison文字列をURLに埋め込まれると適切に処理できない。
- JavaでこれがURLSyntaxException。new URI("https://townewgokgok.github.io/qschecker/?query=(glossary:(GlossDiv:(GlossList:(GlossEntry:(Abbrev:'ISO 8879:1986',Acronym:SGML,GlossDef:(GlossSeeAlso:!(GML,XML),para:'A meta-markup language, used to create markup languages such as DocBook.'),GlossSee:markup,GlossTerm:'Standard Generalized Markup Language',ID:SGML,SortAs:SGML)),title:S),title:'example glossary'))")
- VSCodeのMarkdownプレビューで()のネストが処理されない。これの末尾がリンクに含まれない。http://a/?a=(())

Risonは正常に動作する範囲が狭いかもしれない。

どの文字を使用するかだけでなく、ネストが処理されなかったり、特定の並びが原因で動作しなくなる場合があるようだ。

このアイデアはまだ改善の余地がある。

## URL
https://www.w3.org/Addressing/URL/url-spec.txt

[SOM](#Single_Object_Message)ではURLをある種の[RPC](#RPC)のリクエストオブジェクトと捉えなおした。URLの[ハイパーリンク](#ハイパーリンク)をクリックする事はある種のRPCの実行。

WEBブラウザでURLにアクセスするとWEBサーバはHTMLを返すが、それはRPCの返値であり、WEBブラウザはRPCの返値を自動的にWEBページとして表示している。

だからRPCとハイパーリンクを含めて論じている。この観点からURLにオブジェクトを埋め込みたいという考えも出てくる。このため[Rison](#Rison)が重要になる。

# 問題
## URLの問題
しばしばURL引数が独自仕様になる。[解決策](#Single_Object_Message)

他にURLの問題として、localhostで実行中のアプリを指定する簡易な方法が無い。しばしばアプリは起動時に空いているポートを自動選択するが、URLはポートを固定的に指定する必要がある。hostsの設定もユーザーの手間になる。[解決策](#SOMのURLフォーマット)

## JSON-RPCの問題
送信先情報や転送プロトコルの指定が無く、ハイパーリンクとして使用する観点が無い。[解決策](#SOMのURLフォーマット)

## RPCのクラス定義の共有と自動作成の問題
Jackson等クラスベース言語のJSONライブラリはJSONにクラス名を含めるオプションがある。ObjectMapper#activateDefaultTypingや@JsonTypeInfoなど。

クラス名を含めなくてもメソッドシグネチャを手掛かりとしてクラスを特定できる場合もあるが、引数にインターフェース型や抽象クラスがあると具象クラスを特定できない。

だからクラス名を含める事はクラスベース型の言語で記述されたシステムでは重要。

しかしクラス名を含めるRPCは事前にクラス定義を共有する必要が生じる。しかし、もしメソッドを含めてクラス定義全体を共有すると依存関係を辿ってRPCに無関係なクラスを大量に共有する事になる。しかし共有される必要があるのはクラス定義全体ではなくメンバー変数部分のみで、つまりメソッドを排除したクラス定義で良い。つまりRPCのため（正確にはシリアライズのため）に**同じ完全修飾名のクラスでメソッド定義が排除されたバージョン**を自動作成しシリアライズ側に持たせる必要がある。

- メソッドを排除したクラス定義を自動作成する方法（未解決）
- シリアライズ側にクラス定義を持たせる方法

## 検証処理の問題
RPCでは適切な検証をしないとすぐに深刻な脆弱性になる。

クラスを使わないある種の単純なRPCはセキュリティが成立する。受信したJSONをツリー構造のデータとして扱い、使用する部分のみ検証すればいい。他に考えられる検証は受信したデータのサイズに関する検証だが、やはりクラス定義を必要としない。

しかし、もし受信側がそのツリー構造のデータをクラスに対応付けてデシリアライズ（オブジェクト化）するなら、コンストラクタが動作したり、クラスに実装されているメソッド（呼び出し側が任意に修正できない）によって、１メソッド呼び出すだけで（あるいはデシリアライズ時のコンストラクタ呼び出しだけで）未検証の様々なデータにアクセスしてしまう。データにアクセスする都度検証するという戦略は通用しない。

だからクラスベースのRPCは適切な検証アーキテクチャを考える必要がある。[解決策](#検証処理)

# 解決

## Single_Object_Message
1. SOMプロトコルは[SOMを用いたRPCプロトコル](#SOMプロトコル)です。
2. SOMクラスは[機能毎のクラス](#機能毎にクラスを用意する)です。
3. SOMはSOMクラスのインスタンスです。

2から１個のRPC呼び出しは必ず１個のSOMで記述できるので、[URL引数の独自仕様化](#URLの問題)を防げる。

SOMクラスは機能毎の[周辺検証](#周辺検証)を書く自然な場所になる。JSON-RPCはクラスベースの言語で対応するとメソッド名、引数一覧等を含む汎用クラスを作る事になり機能毎の検証処理を書くアーキテクチャを持っていませんが、SOMクラスは機能毎に作成されそのクラスが検証処理を書く場所になる。

3はSOMがある種のオブジェクトであるという事で、[Rison](#Rison)で文字列にして[URL引数に埋め込める](#SOMのURLフォーマット)。

### SOMプロトコル
クライアントがサーバにただ１つオブジェクト(SOM)を送信してそのオブジェクトのクラス(SOMクラス)がRPC用メソッド（サーバ側が独自にメソッドシグネチャを策定）を持っていてそのメソッドがサーバ側で呼び出される。**だからSOMクラスの指定がプロシージャの指定になる**。

言い換えれば、JSON-RPCのメソッド名の部分がクラス名になったようなものです。

SOMクラスは[RPC用検証インターフェース](#周辺検証)を実装する必要があり、SOMプロトコルはそれを呼び出す。さらにそのRPC用検証インターフェースの実装はメンバー変数及びそこからネストされたオブジェクトについて[モデル検証](#モデル検証)を呼び出す。

### 実装
Tenyu基盤ソフトウェアの実装では、SOMはSingleObjectMessage系クラスで、周辺検証validateAtRpcSynthetic()を実装し、SOMのメンバー変数及びそこからネストされる全てのクラスはValidatableIを実装しモデル検証validateAtRpc()を実装する。このような一貫した検証アーキテクチャによって抽象的なレベルで検証処理のメソッドシグネチャや呼び出しコードを書けるので、検証忘れが起こりにくい。

## SOMのURLフォーマット
基本
```
http://<app>/?som=<rison>
```

例：Risonでオブジェクト(SOM)の内容について多少の可読性がある。（恐らく多くの場合でURLエンコードが必要で％が多発する）
```
http://tenyu/?som=(glossary:(GlossDiv:(GlossList:(GlossEntry:(Abbrev:'ISO 8879:1986',Acronym:SGML,GlossDef:(GlossSeeAlso:!(GML,XML),para:'A meta-markup language, used to create markup languages such as DocBook.'),GlossSee:markup,GlossTerm:'Standard Generalized Markup Language',ID:SGML,SortAs:SGML)),title:S),title:'example glossary'))
```

**現状、Risonに問題があるようなので、kryoでオブジェクトをシリアライズしてurl対応base64した文字列をsomとしている**。

- app  
  アプリ名またはアプリの種類名（テキストエディタ等）。\<user.home>/\<app>/\<app>.txtからポート番号を取得してlocalhostのそのプロセスにアクセスする。だからポート番号を見つけ出せるならどんな文字列でもいい。この動作は私が勝手に言っているだけで存在していない。このようにURLにアプリ名を指定する事は「その人のXXX」を指定しているということ。
- rison  
  SOMをrison文字列にしたもの。クラスベースならクラス名つき

SOM省略形。デフォルトインターフェース（プロセス毎に勝手に決めれる）が無引数で呼び出される。
```
http://<app>/
```

## localhost内のプロセスがRPCでアクセスしてきたユーザーを特定する方法
user.homeから、ユーザーDBを扱うアプリにアクセスして現在そのアプリを起動しているユーザーを取得する。

## 機能毎にクラスを用意する
RPCに関して様々な設計方法を考察したが、結局のところ、Tenyu基盤ソフトウェアのMessageContent系のように機能毎に具象クラスが用意されるのが妥当と思った。そのようなクラスは機能毎の周辺検証を書くのに自然な場所になる。

## 共有されるクラス
機能毎に[SOMクラス](#Single_Object_Message)が作成されるが、外部システムにはそのメンバー変数部分のみあればよく、メソッド部分は要らない。つまり完全修飾名が同じでメンバー変数部分のみのクラス定義を外部システムに提供し、外部システムはそのクラス定義に従いオブジェクトをRison文字列へシリアライズし、受信側システムはメソッド部がある完全なクラス定義へとデシリアライズする。

## HTTP前提
連携する各システムはHTTPサーバを起動しておく。各システムはHTTPサーバを通じてRPCを実現し相互に連携する。

ハイパーリンクのサポートを想定するとHTTPのGET引数は有用。HTTP以外の独自の転送プロトコルの必要性は無い。

異種システム間連携では事前にクラス定義を共有できないので、普及済みのHTTPを前提とするのが妥当。

user.homeにポート番号を書き込むので、そのHTTPサーバはどのポートで待ち受けてもいい。他の（localhostの）アプリはアプリ名さえ分かればポート番号をuser.homeから見つけれる。

## localhost内の異種システム間連携
[URLのアプリ名対応](#SOMのURLフォーマット)が認められるとlocalhost内のシステム間連携が可能になり、「その人のXXX」をハイパーリンクから起動したり操作できるようになる。例えば「その人のタブ型テキストエディタを起動し新しいタブを開いて特定の文字列をセットする」など。

簡単な応用例としてはアプリの操作説明をハイパーリンクを用いて行える。クリックするとリンク先のアプリでウィンドウが開かれる等が可能になる。

もちろんネットワーク越しの連携も可能。

## 検証処理
適切な検証とは何かを考えると[モデル検証](#モデル検証)と[周辺検証](#周辺検証)に分けられる事が分かる。

### モデル検証
オブジェクトのメンバー変数の妥当性について検証する。この検証は周辺検証で扱われる検証をしない。

Tenyu基盤ソフトウェアではValidatableI（もともとStorableという名前だった）が相当する。

例えばRPCの引数に用いられるクラス（SOMクラスのメンバー変数）は必ずこのようなインターフェースを実装すべきだろう。
```
interface ValidatableI{
  boolean validateAtRpc();
}
```

validateAtRpc()はオブジェクトのメンバー変数の状態を検証する。RPCの引数に指定されるオブジェクトはこれを実装するという前提によって、RPCサーバは引数に指定されたオブジェクトについて型チェックのみでなく状態チェック（モデル検証）もできる。

validateAtRpc()のような検証処理の必要性は抽象的なレベルで明らかなので、個々の機能毎ではなく抽象的なコード（ここではRPCサーバ）から呼び出されなければならない。

### 周辺検証
周辺検証はDB検証や通信検証など、非モデル検証のことです。周辺はモデルの周辺のものという意味です。

通信検証の必要性。RPCにおいて誰がいつどのメソッドをどんな引数で呼び出したかというような、様々な情報に基づいた総合的な検証処理をRPC用メソッド毎（機能毎）に定義する必要がある。例えばメソッドによって呼び出し元をlocalhostに限定したいかもしれない。あるいは送信元に応じて許容される引数の状態が違うかもしれない。

恐らく既存のJSON-RPCライブラリでは周辺検証をうまく書く方法が無い。あるJSON-RPCライブラリはTransportレイヤとJSON-RPCレイヤが分離されているようだった。Transportレイヤでは引数のオブジェクトが得られず（テキストのJSON-RPCしかない）、JSON-RPCレイヤでは接続元等のTransport層の情報が得られない。

[SOMクラス](#Single_Object_Message)がこのようなインターフェースを実装する事で周辺検証を設計的に実装し呼び出せる。
```
boolean validateAtRpcSynthetic(byte[] addr, Message m)
```

JSON-RPCにクラスベースの言語が素直に対応すると、メソッド名や引数オブジェクトを含む１個の汎用リクエストクラスを作る事になるが、その汎用クラスで出来る検証処理は汎用的なものに限られ、個々の機能に基づいた検証処理ができない。

**引数のオブジェクト１つ１つの検証処理はモデル検証であり、周辺検証にならない**。個々のRPCの全情報（接続元、呼び出された機能名、引数、システムの状態等）を用いた検証が行われる必要がある。

# 余談
## 世のRPC実装の状況
ある既存のJSON-RPCライブラリは型チェックはしても[状態チェック](#モデル検証)まではしないし、呼び出されたメソッドの側でチェックするという設計はあまり良くない。（抽象的なところで呼び出すべき）

簡単に調べた限りではJSON-RPCの文脈でValidatableのようなインターフェースの実装を引数のクラスに要求するという話（モデル検証）を見かけなかった。そもそもJSONはプロトタイプの世界から来たもので、クラスベースの観点から設計されていない。さらに[周辺検証](#周辺検証)のようなアイデアについても見かけなかった。

世の多くのRPC実装が呼び出されたメソッド毎に検証処理をしていて、脆弱性を生みやすい実装になっている可能性が高い。
抽象的な検証インターフェースを定義し、抽象的なところで検証インターフェースを呼び出す実装が可能で、そちらの方が検証処理の漏れを無くしやすい。

## 考察過程メモ
Tenyu基盤ソフトウェアではTenyuReferenceというモデルへの参照を扱うクラス群がある（あった）。そしてモデル間の参照関係を実現できる。そしてTenyuReferenceにtoURLというようなURL化メソッドを作りハイパーリンク対応を考えていた。

しかし実際のハイパーリンクの例を少し想像すると、必ずしも既存のモデルオブジェクトへのリンクではなく、様々なデータを一覧するページとか、新たにモデルを作成するページへのリンクがありうる。

すると既存のモデルへの参照を前提としていたこれまでのTenyuReferenceという概念では不足で、リファクタリングが生じた。

そこで従来のTenyuReferenceをTenyuReferenceModelとし、その上にTenyuReferenceを作り、TenyuReferenceModelの兄弟としてTenyuReferenceFunc等を作れるようにした。

さらにSOMプロトコルを作りハイパーリンクを一種のRPCとして捉え、他のRPC（アプリ間の自動的な連携）等にも対応できるように考えを整理した。

現在の設計では、TenyuReferenceはSOMインターフェースを実装している。これは機能またはモデルへの参照が常にURL化可能であり、ハイパーリンクをクリックする事でRPCで呼び出される事が可能という事を意味する。（まだ外部プロセスからRPCを受け付ける部分は未実装）

## 連鎖RPC
RPCの実行によってRPCが発生するとデバッグし辛い問題を作り出す可能性が高い。例えば無限ループになる可能性がある。


