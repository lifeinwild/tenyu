package bei7473p5254d69jcuat.tenyu.release1.global;

import java.io.*;

/**
 * Tenyuのクラスはrelease1,2,3といった名前空間で分けられる。
 * 特に、永続化されるクラスが修正される場合、
 * 名前空間について最新releaseにIDE上でクラスを移動させて自動で参照を更新し、
 * 元の名前空間に同名のクラスを作成して内容をコピペし、新しい名前空間で修正を反映する。
 * 新しいバージョンのクラスは直前のバージョンのオブジェクトを受け取るコンストラクタを実装する。
 * これで古いバージョンを読み取る事が出来て、１つずつ新しいバージョンにしていく事で
 * 最新版にできる。
 * 何かクラスを修正する場合、そのクラスをメンバーに含むクラスがChainVersionupでないか
 * 確認する必要がある。メンバークラスの定義が変わっても上記の手順を実行する必要がある。
 * その場合古いクラスを継承して変更されたメンバーだけ再定義すればいいだろう。
 *
 * 永続化されたオブジェクトの親クラスのreleaseが進んだ場合、
 * 連れだって全ての子クラスのreleaseを進めるしかない。
 *
 * 子クラスが存在するクラスをこの方法で更新すると子クラスの継承が問題になるので、
 * クラスを参照している箇所をIDEの機能で検索して手動で修正する。
 * 古い子クラスは古い親クラスを指定し続ける必要がある。
 * そうしないと古いシリアライズされたデータをデシリアライズできない。
 *
 * 状態が変化した場合のみreleaseを進める。
 * メソッドの修正だけなら既存クラスを修正して良い。
 *
 * 空インターフェースという事でアノテーションにする事を一瞬考えたが、
 * コンストラクタに関するインターフェースを定義できないから定義してないだけで、
 * interfaceが意味的に妥当な気がする。
 *
 * @author exceptiontenyu@gmail.com
 *
 */
public interface ChainVersionup extends Serializable {
}
